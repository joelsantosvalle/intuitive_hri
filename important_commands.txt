important commands not to forget to run the script

1st
gcc -o LeapListener LeapMotionListener.c -I/usr/include -L/usr/lib/ultraleap-hand-tracking-service/libLeapC.so -l LeapC && ./LeapListener 

2nd
./LeapListener


ros2 topic pub --once /urscript_interface/script_command std_msgs/msg/String '{data:
"def my_prog():

  set_digital_out(1, True)

  movej(p[0.2, 0.3, 0.8, 0, 0, 3.14], a=1.2, v=0.25, r=0)

  textmsg(\"motion finished\")

end"}'


ros2 topic pub /scaled_pos_joint_traj_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "{header: {stamp: {sec: 0, nanosec: 0}, frame_id: ''}, joint_names: ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint'], points: [{positions: [0.0, -1.57, 1.57, 0.0, 1.57, 0.0], time_from_start: {sec: 1, nanosec: 0}}]}"


ros2 topic pub /scaled_pos_joint_traj_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "{
  header: {
    stamp: {
      sec: 0,
      nanosec: 0
    },
    frame_id: ''
  },
  joint_names: [
    'shoulder_pan_joint', 
    'shoulder_lift_joint', 
    'elbow_joint', 
    'wrist_1_joint', 
    'wrist_2_joint', 
    'wrist_3_joint'
  ],
  points: [
    {
      positions: [0.0, -1.57, 1.57, 0.0, 1.57, 0.0],
      velocities: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
      accelerations: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
      time_from_start: {
        sec: 1,
        nanosec: 0
      }
    }
  ]
}"


ros2 topic pub /pose_command geometry_msgs/msg/PoseStamped "header:
  stamp:
    sec: 0
    nanosec: 0
  frame_id: 'base_link'
pose:
  position:
    x: 0.5
    y: 0.0
    z: 0.5
  orientation:
    x: 0.0
    y: 0.0
    z: 0.0
    w: 1.0"


void orientation_callback(const geometry_msgs::msg::Quaternion::SharedPtr msg)
{
    // Original sensor quaternion
    tf2::Quaternion sensor_quaternion(
        msg->x,
        msg->y,
        msg->z,
        msg->w);

    // Define the rotation between sensor and robot coordinate systems
    // 90 degrees around Z-axis followed by 90 degrees around X-axis
    tf2::Quaternion rotation_quaternion_x, rotation_quaternion_z, combined_rotation;
    rotation_quaternion_x.setRPY(M_PI_2, 0, 0);  // 90 degrees around X-axis
    rotation_quaternion_z.setRPY(0, 0, M_PI_2);  // 90 degrees around Z-axis

    // Combine the rotations: Z followed by X
    combined_rotation = rotation_quaternion_z * rotation_quaternion_x;

    // Apply the combined rotation to the sensor quaternion
    tf2::Quaternion robot_quaternion = combined_rotation * sensor_quaternion;
    robot_quaternion.normalize(); // Normalize the result

    // Convert the quaternion to roll, pitch, yaw for the robot's coordinate system
    tf2::Matrix3x3 m(robot_quaternion);
    double roll, pitch, yaw;
    m.getRPY(roll, pitch, yaw);

    // Update the pose message with roll, pitch, yaw as the orientation
    robot_pose_.orientation.x = roll;
    robot_pose_.orientation.y = pitch;
    robot_pose_.orientation.z = yaw;
}
