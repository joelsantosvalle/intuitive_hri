important commands not to forget to run the script

https://docs.luxonis.com/software/ros/depthai-ros/driver/

1st
gcc -o LeapListener LeapMotionListener.c -I/usr/include -L/usr/lib/ultraleap-hand-tracking-service/libLeapC.so -l LeapC && ./LeapListener 

2nd
./LeapListener


ros2 topic pub --once /urscript_interface/script_command std_msgs/msg/String '{data:
"def my_prog():

  set_digital_out(1, True)

  movej(p[0.2, 0.3, 0.8, 0, 0, 3.14], a=1.2, v=0.25, r=0)

  textmsg(\"motion finished\")

end"}'


ros2 topic pub /scaled_pos_joint_traj_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "{header: {stamp: {sec: 0, nanosec: 0}, frame_id: ''}, joint_names: ['shoulder_pan_joint', 'shoulder_lift_joint', 'elbow_joint', 'wrist_1_joint', 'wrist_2_joint', 'wrist_3_joint'], points: [{positions: [0.0, -1.57, 1.57, 0.0, 1.57, 0.0], time_from_start: {sec: 1, nanosec: 0}}]}"


ros2 topic pub /scaled_pos_joint_traj_controller/joint_trajectory trajectory_msgs/msg/JointTrajectory "{
  header: {
    stamp: {
      sec: 0,
      nanosec: 0
    },
    frame_id: ''
  },
  joint_names: [
    'shoulder_pan_joint', 
    'shoulder_lift_joint', 
    'elbow_joint', 
    'wrist_1_joint', 
    'wrist_2_joint', 
    'wrist_3_joint'
  ],
  points: [
    {
      positions: [0.0, -1.57, 1.57, 0.0, 1.57, 0.0],
      velocities: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
      accelerations: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
      time_from_start: {
        sec: 1,
        nanosec: 0
      }
    }
  ]
}"


ros2 topic pub /pose_command geometry_msgs/msg/PoseStamped "header:
  stamp:
    sec: 0
    nanosec: 0
  frame_id: 'base_link'
pose:
  position:
    x: 0.5
    y: 0.0
    z: 0.5
  orientation:
    x: 0.0
    y: 0.0
    z: 0.0
    w: 1.0"


void orientation_callback(const geometry_msgs::msg::Quaternion::SharedPtr msg)
{
    // Original sensor quaternion
    tf2::Quaternion sensor_quaternion(
        msg->x,
        msg->y,
        msg->z,
        msg->w);

    // Define the rotation between sensor and robot coordinate systems
    // 90 degrees around Z-axis followed by 90 degrees around X-axis
    tf2::Quaternion rotation_quaternion_x, rotation_quaternion_z, combined_rotation;
    rotation_quaternion_x.setRPY(M_PI_2, 0, 0);  // 90 degrees around X-axis
    rotation_quaternion_z.setRPY(0, 0, M_PI_2);  // 90 degrees around Z-axis

    // Combine the rotations: Z followed by X
    combined_rotation = rotation_quaternion_z * rotation_quaternion_x;

    // Apply the combined rotation to the sensor quaternion
    tf2::Quaternion robot_quaternion = combined_rotation * sensor_quaternion;
    robot_quaternion.normalize(); // Normalize the result

    // Convert the quaternion to roll, pitch, yaw for the robot's coordinate system
    tf2::Matrix3x3 m(robot_quaternion);
    double roll, pitch, yaw;
    m.getRPY(roll, pitch, yaw);

    // Update the pose message with roll, pitch, yaw as the orientation
    robot_pose_.orientation.x = roll;
    robot_pose_.orientation.y = pitch;
    robot_pose_.orientation.z = yaw;
}



void orientation_callback(const geometry_msgs::msg::Quaternion::SharedPtr msg)
    {
        // Original quaternion from the sensor
        tf2::Quaternion sensor_quaternion(
            msg->x,
            msg->y,
            msg->z,
            msg->w);

        // Define the transformation from sensor to robot
        tf2::Matrix3x3 rotation_matrix(
            0,  0, 1,  // Robot's X axis = Sensor's Z axis
            1,  0, 0,  // Robot's Y axis = Sensor's X axis (but will be negated)
            0,  1, 0   // Robot's Z axis = Sensor's Y axis
        );

        // Apply the transformation
        tf2::Quaternion transformed_quaternion = sensor_quaternion * rotation_matrix.transpose().getRotation();

        // Convert the transformed quaternion to roll, pitch, and yaw
        tf2::Matrix3x3 m(transformed_quaternion);
        double roll, pitch, yaw;
        m.getRPY(roll, pitch, yaw);

        // Print or use roll, pitch, yaw as needed
        RCLCPP_INFO(this->get_logger(), "Roll: %f, Pitch: %f, Yaw: %f", roll, pitch, yaw);
    }


    void orientation_callback(const geometry_msgs::msg::Quaternion::SharedPtr msg)
    {
        // Original quaternion from the sensor
        tf2::Quaternion sensor_quaternion(
            msg->x,
            msg->y,
            msg->z,
            msg->w);

        // Define the quaternion that rotates from sensor frame to robot frame
        tf2::Quaternion rotation_quaternion;
        rotation_quaternion.setRPY(M_PI_2, 0.0, M_PI_2); // Rotate 90 degrees around X, then 90 degrees around Z

        // Apply the transformation
        tf2::Quaternion robot_quaternion = rotation_quaternion * sensor_quaternion;

        // Convert the transformed quaternion to roll, pitch, and yaw
        tf2::Matrix3x3 m(robot_quaternion);
        double roll, pitch, yaw;
        m.getRPY(roll, pitch, yaw);

        // Print or use roll, pitch, yaw as needed
        RCLCPP_INFO(this->get_logger(), "Roll: %f, Pitch: %f, Yaw: %f", roll, pitch, yaw);




        // Convert the robot quaternion to axis-angle representation
        tf2Scalar angle = robot_quaternion.getAngle();
        tf2::Vector3 axis = robot_quaternion.getAxis();

        // Normalize the axis vector (just to ensure it's a unit vector)
        axis.normalize();

        // Print the axis-angle representation
        RCLCPP_INFO(this->get_logger(), "Axis: [X: %f, Y: %f, Z: %f], Angle: %f", axis.x(), axis.y(), axis.z(), angle);





#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>
#include <tf2/LinearMath/Quaternion.h>
#include <geometry_msgs/msg/quaternion.hpp>
#include <rclcpp/rclcpp.hpp>
#include <iostream>

void orientation_callback(const geometry_msgs::msg::Quaternion::SharedPtr msg)
{
    // Step 1: Convert the incoming geometry_msgs::msg::Quaternion to tf2::Quaternion
    tf2::Quaternion sensor_quat;
    tf2::fromMsg(*msg, sensor_quat);

    // Step 2: Define the rotation that will convert the sensor frame to the robot frame
    // The sensor frame has x (left), y (up), z (forward)
    // The robot frame has x (left), y (forward), z (up)
    // So, we need to rotate around the x-axis by 90 degrees (pi/2 radians)
    tf2::Quaternion rotation;
    rotation.setRPY(-M_PI_2, 0, 0); // Rotate around X by -90 degrees (because y goes to z, and z goes to -y)

    // Step 3: Apply the rotation to the sensor quaternion to get the robot quaternion
    tf2::Quaternion robot_quat = rotation * sensor_quat;

    // Step 4: Normalize the resulting quaternion (good practice)
    robot_quat.normalize();

    // Step 5: Convert the quaternion to axis-angle representation
    tf2::Vector3 axis = robot_quat.getAxis();
    double angle = robot_quat.getAngle();

    // Step 6: Compute the rotation components Rx, Ry, Rz for the robot
    double Rx = axis.x() * angle;
    double Ry = axis.y() * angle;
    double Rz = axis.z() * angle;

    // Debugging output
    std::cout << "Rotation Axis: (" << axis.x() << ", " << axis.y() << ", " << axis.z() << ")\n";
    std::cout << "Rotation Angle: " << angle << "\n";
    std::cout << "Rx: " << Rx << ", Ry: " << Ry << ", Rz: " << Rz << "\n";

    // Now you can use {x, y, z, Rx, Ry, Rz} to command the robot
    // Assuming x, y, z are from another part of your program or sensor data
    double x = 0.0;  // Example x value
    double y = 0.0;  // Example y value
    double z = 0.0;  // Example z value

    // Command the robot with {x, y, z, Rx, Ry, Rz}
    // Your robot control function should be called here
    // For example: robot_command(x, y, z, Rx, Ry, Rz);
}



// Step 1: Convert the incoming geometry_msgs::msg::Quaternion to tf2::Quaternion
    tf2::Quaternion sensor_quat;
    tf2::fromMsg(*msg, sensor_quat);

    // Step 2: Convert quaternion to RPY (roll, pitch, yaw)
    double roll, pitch, yaw;
    tf2::Matrix3x3(sensor_quat).getRPY(roll, pitch, yaw);

    // Debugging output for RPY
    std::cout << "Sensor RPY: Roll = " << roll << ", Pitch = " << pitch << ", Yaw = " << yaw << "\n";

    // Step 3: Apply the rotation of -90 degrees (which is -M_PI_2 radians) around the X-axis
    roll += -M_PI_2;  // Adjust roll by -90 degrees

    // Debugging output for adjusted RPY
    std::cout << "Adjusted RPY: Roll = " << roll << ", Pitch = " << pitch << ", Yaw = " << yaw << "\n";

    // Step 4: Convert the adjusted RPY back to a quaternion
    tf2::Quaternion robot_quat;
    robot_quat.setRPY(roll, pitch, yaw);

    // Step 5: Normalize the resulting quaternion (good practice)
    robot_quat.normalize();

    // Step 6: Convert the quaternion to axis-angle representation
    tf2::Vector3 axis = robot_quat.getAxis();
    double angle = robot_quat.getAngle();

    // Step 7: Compute the rotation components Rx, Ry, Rz for the robot
    double Rx = axis.x() * angle;
    double Ry = axis.y() * angle;
    double Rz = axis.z() * angle;

    // Debugging output to check intermediate values
    std::cout << "Robot Quaternion: (" << robot_quat.x() << ", " << robot_quat.y() << ", " << robot_quat.z() << ", " << robot_quat.w() << ")\n";
    std::cout << "Rotation Axis: (" << axis.x() << ", " << axis.y() << ", " << axis.z() << ")\n";
    std::cout << "Rotation Angle: " << angle << "\n";
    std::cout << "Rx: " << Rx << ", Ry: " << Ry << ", Rz: " << Rz << "\n";


// Step 1: Convert the incoming geometry_msgs::msg::Quaternion to tf2::Quaternion
        tf2::Quaternion sensor_quat;
        tf2::fromMsg(*msg, sensor_quat);

        // Step 2: Convert quaternion to RPY (roll, pitch, yaw)
        double roll, pitch, yaw;
        tf2::Matrix3x3(sensor_quat).getRPY(roll, pitch, yaw);

        std::cout << roll << " " << pitch << " " << yaw << std::endl;  

        tf2::Quaternion rotation_x(tf2::Vector3(1.0, 0.0, 0.0), -M_PI_2);
        tf2::Quaternion rotation_y(tf2::Vector3(0.0, 1.0, 0.0), M_PI);

        tf2::Quaternion rotation = rotation_x * rotation_y;

        tf2::Quaternion robot_quat = rotation * sensor_quat;

        // Step 5: Normalize the resulting quaternion (good practice)
        robot_quat.normalize();

        // Step 6: Convert the quaternion to axis-angle representation
        tf2::Vector3 axis = robot_quat.getAxis();
        double angle = robot_quat.getAngle();

        // Step 7: Compute the rotation components Rx, Ry, Rz for the robot
        double Rx = axis.x() * angle;
        double Ry = axis.y() * angle;
        double Rz = axis.z() * angle;

        robot_pose_.orientation.x = Rz;
        robot_pose_.orientation.y = Ry;
        robot_pose_.orientation.z = Rx;

/opt/ros/humble/include/message_filters/message_filters/signal9.h:228:14: note: provided for ‘template<class T, class P0, class P1> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1), T*) [with T = T; P0 = P0; P1 = P1; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  228 |   Connection addCallback(void(T::*callback)(P0, P1), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:234:14: note: candidate: ‘template<class T, class P0, class P1, class P2> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1, P2), T*) [with T = T; P0 = P0; P1 = P1; P2 = P2; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  234 |   Connection addCallback(void(T::*callback)(P0, P1, P2), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:234:14: note:   template argument deduction/substitution failed:
/opt/ros/humble/include/message_filters/message_filters/signal9.h:280:40: error: wrong number of template arguments (9, should be 4)
  272 |     return addCallback<const M0ConstPtr&,
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  273 |                      const M1ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  274 |                      const M2ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  275 |                      const M3ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  276 |                      const M4ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  277 |                      const M5ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  278 |                      const M6ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  279 |                      const M7ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  280 |                      const M8ConstPtr&>(std::bind(callback, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9));
      |                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:234:14: note: provided for ‘template<class T, class P0, class P1, class P2> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1, P2), T*) [with T = T; P0 = P0; P1 = P1; P2 = P2; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  234 |   Connection addCallback(void(T::*callback)(P0, P1, P2), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:240:14: note: candidate: ‘template<class T, class P0, class P1, class P2, class P3> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1, P2, P3), T*) [with T = T; P0 = P0; P1 = P1; P2 = P2; P3 = P3; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  240 |   Connection addCallback(void(T::*callback)(P0, P1, P2, P3), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:240:14: note:   template argument deduction/substitution failed:
/opt/ros/humble/include/message_filters/message_filters/signal9.h:280:40: error: wrong number of template arguments (9, should be 5)
  272 |     return addCallback<const M0ConstPtr&,
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  273 |                      const M1ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  274 |                      const M2ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  275 |                      const M3ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  276 |                      const M4ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  277 |                      const M5ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  278 |                      const M6ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  279 |                      const M7ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  280 |                      const M8ConstPtr&>(std::bind(callback, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9));
      |                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~




#include <rclcpp/rclcpp.hpp>
#include <std_msgs/msg/float32.hpp>
#include <std_msgs/msg/string.hpp>
#include <geometry_msgs/msg/point.hpp>
#include <geometry_msgs/msg/vector3.hpp>
#include <map>
#include <vector>
#include <sstream>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>

// Command structure to hold position and joint angles, position in meters and orientation in radians
struct Command {
    geometry_msgs::msg::Vector3 position;  // Dynamic x, y, z values
    geometry_msgs::msg::Vector3 orientation;      // Joint angles
};

// Command structure to hold position and joint angles, the joint angles passed to this function should be in radians not degrees
struct CommandJoints {
    std::vector<double> joint_angles;      // Vector to hold 6 joint angles

    // Constructor to initialize the joint_angles vector with 6 elements
    CommandJoints() : joint_angles(6, 0.0) {}
};

// Sensor data structure
struct SensorData {
    float hand_state;
    float hand_normal;
    geometry_msgs::msg::Point hand_position;
    float hand_time_in_sensor;
    geometry_msgs::msg::Point hand_rate_of_change;
};

//Class for communication with the UR3

class UR3Controller {
public:
    UR3Controller(rclcpp::Node::SharedPtr node)
        : node_(node) {
        script_command_pub_ = node_->create_publisher<std_msgs::msg::String>("/urscript_interface/script_command", 10);
    }

    void execute_command(const Command& command) {
        std::ostringstream script;
        script << "def my_prog():\n"
               << "  movej(p[" << command.position.x << ", " << command.position.y << ", " 
               << command.position.z << ", " << command.orientation.x << ", " 
               << command.orientation.y << ", " << command.orientation.z << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";

        std_msgs::msg::String msg;
        msg.data = script.str();
        script_command_pub_->publish(msg);
    }

    void execute_command_joints(const CommandJoints& command) {
        std::ostringstream script;
        script << "def my_prog():\n"
               << "  movej([" << command.joint_angles[0] << ", " << command.joint_angles[1] << ", " 
               << command.joint_angles[2] << ", " << command.joint_angles[3] << ", " 
               << command.joint_angles[4] << ", " << command.joint_angles[5] << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";

        std_msgs::msg::String msg;
        msg.data = script.str();
        script_command_pub_->publish(msg);
    }

private:
    rclcpp::Node::SharedPtr node_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr script_command_pub_;
};

//Class for choosing action to be done 

class ActionManager : public rclcpp::Node
{
public:
    ActionManager(std::string& key) : Node("ActionManager"), command_key(key), ur3_controller_(std::make_shared<UR3Controller>(this->shared_from_this()))
    {
        setup_subscribers();
        setup_synchronizer();
        initialize_commands();
    }

private:
    SensorData sensor_data_;
    std::map<std::string, std::vector<double>> command_map_;
    std::shared_ptr<UR3Controller> ur3_controller_;
    std::string& command_key;
    
    // Subscribers
    message_filters::Subscriber<std_msgs::msg::Float32> hand_state_sub_;
    message_filters::Subscriber<std_msgs::msg::Float32> hand_normal_sub_;
    message_filters::Subscriber<geometry_msgs::msg::Point> hand_position_sub_;
    message_filters::Subscriber<std_msgs::msg::Float32> hand_time_sub_;
    message_filters::Subscriber<geometry_msgs::msg::Point> hand_rate_of_change_sub_;

    // Synchronizer
    std::shared_ptr<message_filters::TimeSynchronizer<
        std_msgs::msg::Float32, std_msgs::msg::Float32, geometry_msgs::msg::Point, 
        std_msgs::msg::Float32, geometry_msgs::msg::Point>> sync_;

    void setup_subscribers() {
        hand_state_sub_.subscribe(this, "hand_state");
        hand_normal_sub_.subscribe(this, "hand_normal");
        hand_position_sub_.subscribe(this, "hand_position_sensor");
        hand_time_sub_.subscribe(this, "hand_time");
        hand_rate_of_change_sub_.subscribe(this, "hand_rate_of_change");
    }

    void setup_synchronizer() {
        sync_.reset(new message_filters::TimeSynchronizer<
            std_msgs::msg::Float32, std_msgs::msg::Float32, geometry_msgs::msg::Point, 
            std_msgs::msg::Float32, geometry_msgs::msg::Point>(
            hand_state_sub_, hand_normal_sub_, hand_position_sub_, hand_time_sub_, 
            hand_rate_of_change_sub_, 10));

        sync_->registerCallback(std::bind(&ActionManager::sensor_data_callback, this, 
                                          std::placeholders::_1, std::placeholders::_2, 
                                          std::placeholders::_3, std::placeholders::_4, 
                                          std::placeholders::_5));
    }

    void initialize_commands() {
        // Initialize the command map with predefined joint angles for each command
        command_map_["left"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["leftapproach"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["lefttop"] = {0.5, -1.0, 1.5};
        command_map_["leftcenter"] = {0.0, -1.0, 1.0};
        command_map_["leftbottom"] = {0.5, -1.57, 1.0};
        command_map_["right"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["rightapproach"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["righttop"] = {0.5, -1.0, 0.5};
        command_map_["rightcenter"] = {0.0, -1.57, 0.5};
        command_map_["rightbottom"] = {0.5, -1.57, 0.5};
        command_map_["center"] = {0.5, -1.0, 1.0};
        command_map_["centertop"] = {0.0, -1.57, 1.0};
        command_map_["centerleftback"] = {0.5, -1.0, 1.5};
        command_map_["centerrightback"] = {0.0, -1.57, 1.0};
        command_map_["home"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
    }

    void sensor_data_callback(const std_msgs::msg::Float32::SharedPtr hand_state,
                              const std_msgs::msg::Float32::SharedPtr hand_normal,
                              const geometry_msgs::msg::Point::SharedPtr hand_position,
                              const std_msgs::msg::Float32::SharedPtr hand_time,
                              const geometry_msgs::msg::Point::SharedPtr hand_rate_of_change)
    {
        update_sensor_data(hand_state, hand_normal, hand_position, hand_time, hand_rate_of_change);
        evaluate_conditions_and_act();
    }

    void update_sensor_data(const std_msgs::msg::Float32::SharedPtr& hand_state,
                            const std_msgs::msg::Float32::SharedPtr& hand_normal,
                            const geometry_msgs::msg::Point::SharedPtr& hand_position,
                            const std_msgs::msg::Float32::SharedPtr& hand_time,
                            const geometry_msgs::msg::Point::SharedPtr& hand_rate_of_change)
    {
        sensor_data_.hand_state = hand_state->data;
        sensor_data_.hand_normal = hand_normal->data;
        sensor_data_.hand_position = *hand_position;
        sensor_data_.hand_time_in_sensor = hand_time->data;
        sensor_data_.hand_rate_of_change = *hand_rate_of_change;
    }

    void evaluate_conditions_and_act() {
        if (should_pick_object_table()) {
            execute_command_joints(command_key); 
        } else if (should_place_object_table()) {
            execute_command_joints(command_key);
        } else if (should_approach_human() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_place_object_operator() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_change_position() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_turn() && correct_hand_position()) {
            execute_command_joints(command_key);
        } else {
            maintain_current_state();
        }
    }

    void execute_command(std::string& command_key) {
        // Find the command in the map
        auto command_it = command_map_.find(command_key);
        
        if (command_it != command_map_.end()) {
            // Get the joint angles associated with the command
            std::vector<double> joint_angles = command_it->second;
            
            // Create a new CommandJoints object to hold the position and angles
            Command command_joints;
            
            // Assign the joint angles
            command_joints.orientation.x = joint_angles[0];
            command_joints.orientation.y = joint_angles[1];
            command_joints.orientation.z = joint_angles[2];
            
            // Populate the position with dynamic sensor data
            command_joints.position.x = sensor_data_.hand_position.x;
            command_joints.position.y = sensor_data_.hand_position.y;
            command_joints.position.z = sensor_data_.hand_position.z;
            
            // Execute the command using the UR3 controller
            ur3_controller_->execute_command_joints(command_joints);
        } else {
            RCLCPP_WARN(this->get_logger(), "Command not found: %s", command_key.c_str());
        }
    }

    // Function to execute command using joint angles
    void execute_command_joints(std::string& command_key) {
        // Find the command in the map
        auto command_it = command_map_.find(command_key);
        
        if (command_it != command_map_.end()) {
            CommandJoints command_joints;
            command_joints.joint_angles = command_it->second;
            ur3_controller_->execute_command_joints(command_joints);
        } else {
            RCLCPP_WARN(this->get_logger(), "Command not found: %s", command_key.c_str());
        }
    }

    bool correct_hand_position()
    {
        return true;
    }

    bool should_pick_object_table() {
        return sensor_data_.hand_state > 0.5 && sensor_data_.hand_time_in_sensor > 2.0;
    }

    bool should_place_object_table() {
        // Example condition for placing an object
        return sensor_data_.hand_normal > 0.7 && sensor_data_.hand_rate_of_change.z > 0.3;
    }

    bool should_approach_human() {
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_place_object_operator(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_change_position(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_turn(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    void maintain_current_state() {
        RCLCPP_INFO(this->get_logger(), "Maintaining current state");
    }
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    std::string& key = "left";
    rclcpp::spin(std::make_shared<ActionManager>(key));
    rclcpp::shutdown();
    return 0;
}



Starting >>> intuitive_hri
--- stderr: intuitive_hri                             
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:103:41: error: ‘ExactTime’ in namespace ‘message_filters’ does not name a template type
  103 |     using SyncPolicy = message_filters::ExactTime<
      |                                         ^~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:107:43: error: ‘SyncPolicy’ was not declared in this scope
  107 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                           ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:107:53: error: template argument 1 is invalid
  107 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                                     ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In constructor ‘ActionManager::ActionManager()’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:93:17: warning: ‘ActionManager::command_key’ will be initialized after [-Wreorder]
   93 |     std::string command_key;
      |                 ^~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:92:36: warning:   ‘std::shared_ptr<UR3Controller> ActionManager::ur3_controller_’ [-Wreorder]
   92 |     std::shared_ptr<UR3Controller> ur3_controller_;
      |                                    ^~~~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:82:5: warning:   when initialized here [-Wreorder]
   82 |     ActionManager() : Node("ActionManager"), command_key(" "), ur3_controller_(std::make_shared<UR3Controller>(this->shared_from_this()))
      |     ^~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In member function ‘void ActionManager::setup_synchronizer()’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:119:35: error: ‘SyncPolicy’ was not declared in this scope
  119 |         sync_.reset(new SyncType( SyncPolicy(10),
      |                                   ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:121:41: error: new initializer expression list treated as compound expression [-fpermissive]
  121 |             hand_rate_of_change_sub_, 10));
      |                                         ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:123:16: error: request for member ‘registerCallback’ in ‘*((std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>*)(&((ActionManager*)this)->ActionManager::sync_))->std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::operator->()’, which is of non-class type ‘std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘int’}
  123 |         sync_->registerCallback(std::bind(&ActionManager::sensor_data_callback, this,


d --packages-select intuitive_hri
Starting >>> intuitive_hri
--- stderr: intuitive_hri                             
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:106:58: error: expected unqualified-id before ‘>’ token
  106 |         std_msgs::msg::Float32, geometry_msgs::msg::Point>> sync_;
      |                                                          ^~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:108:43: error: ‘SyncPolicy’ was not declared in this scope
  108 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                           ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:108:53: error: template argument 1 is invalid
  108 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                                     ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In constructor ‘ActionManager::ActionManager()’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:94:17: warning: ‘ActionManager::command_key’ will be initialized after [-Wreorder]
   94 |     std::string command_key;
      |                 ^~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:93:36: warning:   ‘std::shared_ptr<UR3Controller> ActionManager::ur3_controller_’ [-Wreorder]
   93 |     std::shared_ptr<UR3Controller> ur3_controller_;
      |                                    ^~~~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:83:5: warning:   when initialized here [-Wreorder]
   83 |     ActionManager() : Node("ActionManager"), command_key(" "), ur3_controller_(std::make_shared<UR3Controller>(this->shared_from_this()))
      |     ^~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In member function ‘void ActionManager::setup_synchronizer()’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:120:57: error: ‘SyncPolicy’ was not declared in this scope
  120 |         sync_ = std::make_shared<SyncType>(new SyncType(SyncPolicy(10),
      |                                                         ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:122:37: error: new initializer expression list treated as compound expression [-fpermissive]
  122 |             hand_rate_of_change_sub_));
      |                                     ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:124:16: error: request for member ‘registerCallback’ in ‘*((std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>*)(&((ActionManager*)this)->ActionManager::sync_))->std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::operator->()’, which is of non-class type ‘std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘int’}
  124 |         sync_->registerCallback(std::bind(&ActionManager::sensor_data_callback, this,
      |                ^~~~~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In member function ‘void ActionManager::execute_command(std::string)’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:212:53: error: cannot convert ‘Command’ to ‘const CommandJoints&’
  212 |             ur3_controller_->execute_command_joints(command_joints);
      |                                                     ^~~~~~~~~~~~~~
      |                                                     |
      |                                                     Command
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:59:54: note:   initializing argument 1 of ‘void UR3Controller::execute_command_joints(const CommandJoints&)’
   59 |     void execute_command_joints(const CommandJoints& command) {
      |                                 ~~~~~~~~~~~~~~~~~~~~~^~~~~~~
gmake[2]: *** [CMakeFiles/RobotControl.dir/build.make:76: CMakeFiles/RobotControl.dir/src/RobotControl.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:193: CMakeFiles/RobotControl.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
---
Failed   <<< intuitive_hri [7.29s, exited with code 2]

Summary: 0 packages finished [7.79s]
  1 package failed: intuitive_hri
  1 package had stderr output: intuitive_hri

      |                ^~~~~~~~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In member function ‘void ActionManager::execute_command(std::string&)’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:211:53: error: cannot convert ‘Command’ to ‘const CommandJoints&’
  211 |             ur3_controller_->execute_command_joints(command_joints);
      |                                                     ^~~~~~~~~~~~~~
      |                                                     |
      |                                                     Command
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:58:54: note:   initializing argument 1 of ‘void UR3Controller::execute_command_joints(const CommandJoints&)’
   58 |     void execute_command_joints(const CommandJoints& command) {
      |                                 ~~~~~~~~~~~~~~~~~~~~~^~~~~~~
gmake[2]: *** [CMakeFiles/RobotControl.dir/build.make:76: CMakeFiles/RobotControl.dir/src/RobotControl.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:193: CMakeFiles/RobotControl.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
---
Failed   <<< intuitive_hri [7.20s, exited with code 2]

Summary: 0 packages finished [8.50s]
  1 package failed: intuitive_hri
  1 package had stderr output: intuitive_hri



// Define the SyncPolicy and SyncType inside the class, but outside of any function
    using SyncPolicy = message_filters::sync_policies::ExactTime<
        std_msgs::msg::Float32, std_msgs::msg::Float32, 
        geometry_msgs::msg::Point, std_msgs::msg::Float32, 
        geometry_msgs::msg::Point>;

    using SyncType = message_filters::Synchronizer<SyncPolicy>;

    // Declare a shared pointer to the synchronizer
    std::shared_ptr<SyncType> sync_;

d --packages-select intuitive_hri
Starting >>> intuitive_hri
--- stderr: intuitive_hri                             
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:106:58: error: expected unqualified-id before ‘>’ token
  106 |         std_msgs::msg::Float32, geometry_msgs::msg::Point>> SyncPolicy;
      |                                                          ^~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:108:43: error: ‘SyncPolicy’ was not declared in this scope
  108 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                           ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:108:53: error: template argument 1 is invalid
  108 |     typedef message_filters::Synchronizer<SyncPolicy> SyncType;
      |                                                     ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp: In member function ‘void ActionManager::setup_synchronizer()’:
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:120:53: error: ‘SyncPolicy’ was not declared in this scope
  120 |         sync_ = std::make_shared<SyncType>(SyncType(SyncPolicy(10),
      |                                                     ^~~~~~~~~~
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:122:37: error: expression list treated as compound expression in functional cast [-fpermissive]
  122 |             hand_rate_of_change_sub_));
      |                                     ^
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:124:16: error: request for member ‘registerCallback’ in ‘*((std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>*)(&((ActionManager*)this)->ActionManager::sync_))->std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::operator->()’, which is of non-class type ‘std::__shared_ptr_access<int, __gnu_cxx::_S_atomic, false, false>::element_type’ {aka ‘int’}
  124 |         sync_->registerCallback(std::bind(&ActionManager::sensor_data_callback, this,
      |                ^~~~~~~~~~~~~~~~
gmake[2]: *** [CMakeFiles/RobotControl.dir/build.make:76: CMakeFiles/RobotControl.dir/src/RobotControl.cpp.o] Error 1
gmake[1]: *** [CMakeFiles/Makefile2:193: CMakeFiles/RobotControl.dir/all] Error 2
gmake: *** [Makefile:146: all] Error 2
---




/opt/ros/humble/include/message_filters/message_filters/signal9.h:258:14: note:   template argument deduction/substitution failed:
/opt/ros/humble/include/message_filters/message_filters/signal9.h:280:40: error: wrong number of template arguments (9, should be 8)
  272 |     return addCallback<const M0ConstPtr&,
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  273 |                      const M1ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  274 |                      const M2ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  275 |                      const M3ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  276 |                      const M4ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  277 |                      const M5ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  278 |                      const M6ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  279 |                      const M7ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  280 |                      const M8ConstPtr&>(std::bind(callback, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9));
      |                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:258:14: note: provided for ‘template<class T, class P0, class P1, class P2, class P3, class P4, class P5, class P6> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1, P2, P3, P4, P5, P6), T*) [with T = T; P0 = P0; P1 = P1; P2 = P2; P3 = P3; P4 = P4; P5 = P5; P6 = P6; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  258 |   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:264:14: note: candidate: ‘template<class T, class P0, class P1, class P2, class P3, class P4, class P5, class P6, class P7> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(void (T::*)(P0, P1, P2, P3, P4, P5, P6, P7), T*) [with T = T; P0 = P0; P1 = P1; P2 = P2; P3 = P3; P4 = P4; P5 = P5; P6 = P6; P7 = P7; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  264 |   Connection addCallback(void(T::*callback)(P0, P1, P2, P3, P4, P5, P6, P7), T* t)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:264:14: note:   template argument deduction/substitution failed:
/opt/ros/humble/include/message_filters/message_filters/signal9.h: In substitution of ‘template<class T, class P0, class P1, class P2, class P3, class P4, class P5, class P6, class P7> message_filters::Connection message_filters::Signal9<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType>::addCallback<T, P0, P1, P2, P3, P4, P5, P6, P7>(void (T::*)(P0, P1, P2, P3, P4, P5, P6, P7), T*) [with T = const std::shared_ptr<const std_msgs::msg::Float32_<std::allocator<void> > >&; P0 = const std::shared_ptr<const std_msgs::msg::Float32_<std::allocator<void> > >&; P1 = const std::shared_ptr<const geometry_msgs::msg::Point_<std::allocator<void> > >&; P2 = const std::shared_ptr<const std_msgs::msg::Float32_<std::allocator<void> > >&; P3 = const std::shared_ptr<const geometry_msgs::msg::Point_<std::allocator<void> > >&; P4 = const std::shared_ptr<const message_filters::NullType>&; P5 = const std::shared_ptr<const message_filters::NullType>&; P6 = const std::shared_ptr<const message_filters::NullType>&; P7 = const std::shared_ptr<const message_filters::NullType>&]’:
/opt/ros/humble/include/message_filters/message_filters/signal9.h:280:40:   required from ‘message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = const std::_Bind<void (ActionManager::*(ActionManager*, std::_Placeholder<1>, std::_Placeholder<2>, std::_Placeholder<3>, std::_Placeholder<4>, std::_Placeholder<5>))(std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >)>; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
/opt/ros/humble/include/message_filters/message_filters/synchronizer.h:298:31:   required from ‘message_filters::Connection message_filters::Synchronizer<Policy>::registerCallback(const C&) [with C = std::_Bind<void (ActionManager::*(ActionManager*, std::_Placeholder<1>, std::_Placeholder<2>, std::_Placeholder<3>, std::_Placeholder<4>, std::_Placeholder<5>))(std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >)>; Policy = message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > >]’
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:124:32:   required from here
/opt/ros/humble/include/message_filters/message_filters/signal9.h:264:14: error: forming pointer to reference type ‘const std::shared_ptr<const std_msgs::msg::Float32_<std::allocator<void> > >&’
/opt/ros/humble/include/message_filters/message_filters/signal9.h: In instantiation of ‘message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = const std::_Bind<void (ActionManager::*(ActionManager*, std::_Placeholder<1>, std::_Placeholder<2>, std::_Placeholder<3>, std::_Placeholder<4>, std::_Placeholder<5>))(std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >)>; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’:
/opt/ros/humble/include/message_filters/message_filters/synchronizer.h:298:31:   required from ‘message_filters::Connection message_filters::Synchronizer<Policy>::registerCallback(const C&) [with C = std::_Bind<void (ActionManager::*(ActionManager*, std::_Placeholder<1>, std::_Placeholder<2>, std::_Placeholder<3>, std::_Placeholder<4>, std::_Placeholder<5>))(std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >, std::shared_ptr<std_msgs::msg::Float32_<std::allocator<void> > >, std::shared_ptr<geometry_msgs::msg::Point_<std::allocator<void> > >)>; Policy = message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > >]’
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:124:32:   required from here
/opt/ros/humble/include/message_filters/message_filters/signal9.h:270:14: note: candidate: ‘template<class C> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = C; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  270 |   Connection addCallback( C& callback)
      |              ^~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:270:14: note:   template argument deduction/substitution failed:
/opt/ros/humble/include/message_filters/message_filters/signal9.h:280:40: error: wrong number of template arguments (9, should be 1)
  272 |     return addCallback<const M0ConstPtr&,
      |            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  273 |                      const M1ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  274 |                      const M2ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  275 |                      const M3ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  276 |                      const M4ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  277 |                      const M5ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  278 |                      const M6ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  279 |                      const M7ConstPtr&,
      |                      ~~~~~~~~~~~~~~~~~~ 
  280 |                      const M8ConstPtr&>(std::bind(callback, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3, std::placeholders::_4, std::placeholders::_5, std::placeholders::_6, std::placeholders::_7, std::placeholders::_8, std::placeholders::_9));
      |                      ~~~~~~~~~~~~~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/ros/humble/include/message_filters/message_filters/signal9.h:270:14: note: provided for ‘template<class C> message_filters::Connection message_filters::Signal9<M0, M1, M2, M3, M4, M5, M6, M7, M8>::addCallback(C&) [with C = C; M0 = std_msgs::msg::Float32_<std::allocator<void> >; M1 = std_msgs::msg::Float32_<std::allocator<void> >; M2 = geometry_msgs::msg::Point_<std::allocator<void> >; M3 = std_msgs::msg::Float32_<std::allocator<void> >; M4 = geometry_msgs::msg::Point_<std::allocator<void> >; M5 = message_filters::NullType; M6 = message_filters::NullType; M7 = message_filters::NullType; M8 = message_filters::NullType]’
  270 |   Connection addCallback( C& callback)
      |              ^~~~~~~~~~~
In file included from /usr/include/x86_64-linux-gnu/c++/11/bits/c++allocator.h:33,
                 from /usr/include/c++/11/bits/allocator.h:46,
                 from /usr/include/c++/11/memory:64,
                 from /opt/ros/humble/include/rclcpp/rclcpp/rclcpp.hpp:153,
                 from /home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:1:
/usr/include/c++/11/ext/new_allocator.h: In instantiation of ‘void __gnu_cxx::new_allocator<_Tp>::construct(_Up*, _Args&& ...) [with _Up = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >]’:
/usr/include/c++/11/bits/alloc_traits.h:516:17:   required from ‘static void std::allocator_traits<std::allocator<_Tp1> >::construct(std::allocator_traits<std::allocator<_Tp1> >::allocator_type&, _Up*, _Args&& ...) [with _Up = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; std::allocator_traits<std::allocator<_Tp1> >::allocator_type = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >]’
/usr/include/c++/11/bits/shared_ptr_base.h:519:39:   required from ‘std::_Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp>::_Sp_counted_ptr_inplace(_Alloc, _Args&& ...) [with _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Alloc = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
/usr/include/c++/11/bits/shared_ptr_base.h:650:16:   required from ‘std::__shared_count<_Lp>::__shared_count(_Tp*&, std::_Sp_alloc_shared_tag<_Alloc>, _Args&& ...) [with _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Alloc = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
/usr/include/c++/11/bits/shared_ptr_base.h:1342:14:   required from ‘std::__shared_ptr<_Tp, _Lp>::__shared_ptr(std::_Sp_alloc_shared_tag<_Tp>, _Args&& ...) [with _Alloc = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; __gnu_cxx::_Lock_policy _Lp = __gnu_cxx::_S_atomic]’
/usr/include/c++/11/bits/shared_ptr.h:409:59:   required from ‘std::shared_ptr<_Tp>::shared_ptr(std::_Sp_alloc_shared_tag<_Tp>, _Args&& ...) [with _Alloc = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}; _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >]’
/usr/include/c++/11/bits/shared_ptr.h:862:14:   required from ‘std::shared_ptr<_Tp> std::allocate_shared(const _Alloc&, _Args&& ...) [with _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Alloc = std::allocator<message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}]’
/usr/include/c++/11/bits/shared_ptr.h:878:39:   required from ‘std::shared_ptr<_Tp> std::make_shared(_Args&& ...) [with _Tp = message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >; _Args = {message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, message_filters::NullType, message_filters::NullType, message_filters::NullType, message_filters::NullType> >}]’
/home/esseo/intuitive_hr_interaction_ws/src/intuitive_hri/src/RobotControl.cpp:120:43:   required from here
/usr/include/c++/11/ext/new_allocator.h:162:11: error: use of deleted function ‘message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >::Synchronizer(const message_filters::Synchronizer<message_filters::sync_policies::ExactTime<std_msgs::msg::Float32_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> >, std_msgs::msg::Float32_<std::allocator<void> >, geometry_msgs::msg::Point_<std::allocator<void> > > >&)’
  162 |         { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
      |           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    void setup_subscribers() {
         // Subscriber to hand position
        hand_state_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_state", 10,
            std::bind(&ActionManager::sensor_data_callback, this, std::placeholders::_1));
             // Subscriber to hand position
        hand_normal_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_normal", 10,
            std::bind(&ActionManager::sensor_data_callback, this, std::placeholders::_1));
             // Subscriber to hand position
        hand_position_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_position_sensor", 10,
            std::bind(&ActionManager::sensor_data_callback, this, std::placeholders::_1));
             // Subscriber to hand position
        hand_time_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_time", 10,
            std::bind(&ActionManager::sensor_data_callback, this, std::placeholders::_1));
             // Subscriber to hand position
        hand_rate_of_change_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_rate_of_change", 10,
            std::bind(&ActionManager::sensor_data_callback, this, std::placeholders::_1));
    }

    void initialize_commands() {
        // Initialize the command map with predefined joint angles for each command
        command_map_["left"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["leftapproach"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["lefttop"] = {0.5, -1.0, 1.5};
        command_map_["leftcenter"] = {0.0, -1.0, 1.0};
        command_map_["leftbottom"] = {0.5, -1.57, 1.0};
        command_map_["right"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["rightapproach"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["righttop"] = {0.5, -1.0, 0.5};
        command_map_["rightcenter"] = {0.0, -1.57, 0.5};
        command_map_["rightbottom"] = {0.5, -1.57, 0.5};
        command_map_["center"] = {0.5, -1.0, 1.0};
        command_map_["centertop"] = {0.0, -1.57, 1.0};
        command_map_["centerleftback"] = {0.5, -1.0, 1.5};
        command_map_["centerrightback"] = {0.0, -1.57, 1.0};
        command_map_["home"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
    }

    void sensor_data_callback(const std_msgs::msg::Float32::SharedPtr hand_state,
                              const std_msgs::msg::Float32::SharedPtr hand_normal,
                              const geometry_msgs::msg::Point::SharedPtr hand_position,
                              const std_msgs::msg::Float32::SharedPtr hand_time,
                              const geometry_msgs::msg::Point::SharedPtr hand_rate_of_change)
    {
        //update_sensor_data(hand_state, hand_normal, hand_position, hand_time, hand_rate_of_change);
        //evaluate_conditions_and_act();
        int one = 1;
        if(one == 1)
        {
            ur3_controller_->execute_command();
            one++;
        }
    }

  // Subscribers
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_state_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_normal_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr hand_position_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_time_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr hand_rate_of_change_sub_;






    void setup_subscribers() {
        // Subscriber to hand state
        hand_state_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_state", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_state");
            });

        // Subscriber to hand normal
        hand_normal_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_normal", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_normal");
            });

        // Subscriber to hand position
        hand_position_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_position_sensor", 10,
            [this](const geometry_msgs::msg::Point::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_position");
            });

        // Subscriber to hand time
        hand_time_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_time", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_time");
            });

        // Subscriber to hand rate of change
        hand_rate_of_change_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_rate_of_change", 10,
            [this](const geometry_msgs::msg::Point::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_rate_of_change");
            });
    }

    void sensor_data_callback(const std_msgs::msg::Float32::SharedPtr msg, const std::string& topic) {
        // Handle Float32 messages
        RCLCPP_INFO(this->get_logger(), "Received %s: %f", topic.c_str(), msg->data);
        // Call the function to handle all messages here
        process_received_data();
    }

    void sensor_data_callback(const geometry_msgs::msg::Point::SharedPtr msg, const std::string& topic) {
        // Handle Point messages
        RCLCPP_INFO(this->get_logger(), "Received %s: x: %f, y: %f, z: %f", topic.c_str(), msg->x, msg->y, msg->z);
        // Call the function to handle all messages here
        process_received_data();
    }













#include <rclcpp/rclcpp.hpp>
#include <std_msgs/msg/float32.hpp>
#include <std_msgs/msg/string.hpp>
#include <geometry_msgs/msg/point.hpp>
#include <geometry_msgs/msg/vector3.hpp>
#include <map>
#include <vector>
#include <sstream>
#include <message_filters/subscriber.h>
#include <message_filters/time_synchronizer.h>
#include <message_filters/sync_policies/exact_time.h>

// Command structure to hold position and joint angles, position in meters and orientation in radians
struct Command {
    geometry_msgs::msg::Vector3 position;  // Dynamic x, y, z values
    geometry_msgs::msg::Vector3 orientation;      // Joint angles
};

// Command structure to hold position and joint angles, the joint angles passed to this function should be in radians not degrees
struct CommandJoints {
    std::vector<double> joint_angles;      // Vector to hold 6 joint angles

    // Constructor to initialize the joint_angles vector with 6 elements
    CommandJoints() : joint_angles(6, 0.0) {}
};

// Sensor data structure
struct SensorData {
    float hand_state;
    float hand_normal;
    geometry_msgs::msg::Point hand_position;
    float hand_time_in_sensor;
    geometry_msgs::msg::Point hand_rate_of_change;
};

//Class for communication with the UR3

class UR3Controller {
public:
    UR3Controller(rclcpp::Node::SharedPtr node)
        : node_(node) {
        script_command_pub_ = node_->create_publisher<std_msgs::msg::String>("/urscript_interface/script_command", 10);
    }

    void execute_command() {
        std::ostringstream script;

        script << "def my_prog():\n"
               << "  movej(p[" << 0.246 << ", " << -0.240 << ", " 
               << 0.031 << ", " << 2.077 << ", " 
               << -2.303 << ", " << 1.151 << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";
        /*       
        script << "def my_prog():\n"
               << "  movej(p[" << command.position.x << ", " << command.position.y << ", " 
               << command.position.z << ", " << command.orientation.x << ", " 
               << command.orientation.y << ", " << command.orientation.z << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";
        */
        std_msgs::msg::String msg;
        msg.data = script.str();
        script_command_pub_->publish(msg);
    }

    void execute_command(Command command) {
        std::ostringstream script;
    
        script << "def my_prog():\n"
               << "  movej(p[" << command.position.x << ", " << command.position.y << ", " 
               << command.position.z << ", " << command.orientation.x << ", " 
               << command.orientation.y << ", " << command.orientation.z << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";

        std_msgs::msg::String msg;
        msg.data = script.str();
        script_command_pub_->publish(msg);
    }

    void execute_command_joints(CommandJoints command) {
        std::ostringstream script;
        script << "def my_prog():\n"
               << "  movej([" << command.joint_angles[0] << ", " << command.joint_angles[1] << ", " 
               << command.joint_angles[2] << ", " << command.joint_angles[3] << ", " 
               << command.joint_angles[4] << ", " << command.joint_angles[5] << "], a=1.2, v=0.25, r=0)\n"
               << "  textmsg(\"motion finished\")\n"
               << "end";

        std_msgs::msg::String msg;
        msg.data = script.str();
        script_command_pub_->publish(msg);
    }

private:
    rclcpp::Node::SharedPtr node_;
    rclcpp::Publisher<std_msgs::msg::String>::SharedPtr script_command_pub_;
};

//Class for choosing action to be done 

class ActionManager : public rclcpp::Node
{
public:
    ActionManager() : Node("ActionManager"), ur3_controller_(std::make_shared<UR3Controller>(this->shared_from_this())), command_key(" ")
    {
        std::cout << "hello 1" <<std::endl;
        setup_subscribers();
        std::cout << "hello 1" <<std::endl;
        initialize_commands();
        std::cout << "hello 1" <<std::endl;
    }

private:
    SensorData sensor_data_;
    std::map<std::string, std::vector<double>> command_map_;
    std::shared_ptr<UR3Controller> ur3_controller_;
    std::string command_key;

    void setup_subscribers() {
        // Subscriber to hand state
        hand_state_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_state", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_state");
            });

        // Subscriber to hand normal
        hand_normal_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_normal", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_normal");
            });

        // Subscriber to hand position
        hand_position_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_position_sensor", 10,
            [this](const geometry_msgs::msg::Point::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_position");
            });

        // Subscriber to hand time
        hand_time_sub_ = this->create_subscription<std_msgs::msg::Float32>(
            "hand_time", 10,
            [this](const std_msgs::msg::Float32::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_time");
            });

        // Subscriber to hand rate of change
        hand_rate_of_change_sub_ = this->create_subscription<geometry_msgs::msg::Point>(
            "hand_rate_of_change", 10,
            [this](const geometry_msgs::msg::Point::SharedPtr msg) {
                this->sensor_data_callback(msg, "hand_rate_of_change");
            });
    }

    void sensor_data_callback(const std_msgs::msg::Float32::SharedPtr msg, const std::string& topic) {
        // Handle Float32 messages
        RCLCPP_INFO(this->get_logger(), "Received %s: %f", topic.c_str(), msg->data);

        int one = 1;
        if(one == 1)
        {
            ur3_controller_->execute_command();
            one++;
        }
    }

        void sensor_data_callback(const geometry_msgs::msg::Point::SharedPtr msg, const std::string& topic) {
        // Handle Point messages
        RCLCPP_INFO(this->get_logger(), "Received %s: x: %f, y: %f, z: %f", topic.c_str(), msg->x, msg->y, msg->z);
    }

    void initialize_commands() {
        // Initialize the command map with predefined joint angles for each command
        command_map_["left"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["leftapproach"] = {0.0, -1.57, 1.0, 0.0, 0.0, 0.0};
        command_map_["lefttop"] = {0.5, -1.0, 1.5};
        command_map_["leftcenter"] = {0.0, -1.0, 1.0};
        command_map_["leftbottom"] = {0.5, -1.57, 1.0};
        command_map_["right"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["rightapproach"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
        command_map_["righttop"] = {0.5, -1.0, 0.5};
        command_map_["rightcenter"] = {0.0, -1.57, 0.5};
        command_map_["rightbottom"] = {0.5, -1.57, 0.5};
        command_map_["center"] = {0.5, -1.0, 1.0};
        command_map_["centertop"] = {0.0, -1.57, 1.0};
        command_map_["centerleftback"] = {0.5, -1.0, 1.5};
        command_map_["centerrightback"] = {0.0, -1.57, 1.0};
        command_map_["home"] = {0.0, -1.57, 0.5, 0.0, 0.0, 0.0};
    }

    void update_sensor_data(const std_msgs::msg::Float32::SharedPtr& hand_state,
                            const std_msgs::msg::Float32::SharedPtr& hand_normal,
                            const geometry_msgs::msg::Point::SharedPtr& hand_position,
                            const std_msgs::msg::Float32::SharedPtr& hand_time,
                            const geometry_msgs::msg::Point::SharedPtr& hand_rate_of_change)
    {
        sensor_data_.hand_state = hand_state->data;
        sensor_data_.hand_normal = hand_normal->data;
        sensor_data_.hand_position = *hand_position;
        sensor_data_.hand_time_in_sensor = hand_time->data;
        sensor_data_.hand_rate_of_change = *hand_rate_of_change;
    }

    void evaluate_conditions_and_act() {
        if (should_pick_object_table()) {
            execute_command_joints(command_key); 
        } else if (should_place_object_table()) {
            execute_command_joints(command_key);
        } else if (should_approach_human() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_place_object_operator() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_change_position() && correct_hand_position()) {
            execute_command(command_key);
        } else if (should_turn() && correct_hand_position()) {
            execute_command_joints(command_key);
        } else {
            maintain_current_state();
        }
    }

    void execute_command(std::string command_key) {
        // Find the command in the map
        auto command_it = command_map_.find(command_key);
        
        if (command_it != command_map_.end()) {
            // Get the joint angles associated with the command
            std::vector<double> joint_angles = command_it->second;
            
            // Create a new CommandJoints object to hold the position and angles
            Command command_joints;
            
            // Assign the joint angles
            command_joints.orientation.x = joint_angles[0];
            command_joints.orientation.y = joint_angles[1];
            command_joints.orientation.z = joint_angles[2];
            
            // Populate the position with dynamic sensor data
            command_joints.position.x = sensor_data_.hand_position.x;
            command_joints.position.y = sensor_data_.hand_position.y;
            command_joints.position.z = sensor_data_.hand_position.z;
            
            // Execute the command using the UR3 controller
            ur3_controller_->execute_command(command_joints);
        } else {
            RCLCPP_WARN(this->get_logger(), "Command not found: %s", command_key.c_str());
        }
    }

    // Function to execute command using joint angles
    void execute_command_joints(std::string command_key) {
        // Find the command in the map
        auto command_it = command_map_.find(command_key);
        
        if (command_it != command_map_.end()) {
            CommandJoints command_joints;
            command_joints.joint_angles = command_it->second;
            ur3_controller_->execute_command_joints(command_joints);
        } else {
            RCLCPP_WARN(this->get_logger(), "Command not found: %s", command_key.c_str());
        }
    }

    bool correct_hand_position()
    {
        return true;
    }

    bool should_pick_object_table() {
        return sensor_data_.hand_state > 0.5 && sensor_data_.hand_time_in_sensor > 2.0;
    }

    bool should_place_object_table() {
        // Example condition for placing an object
        return sensor_data_.hand_normal > 0.7 && sensor_data_.hand_rate_of_change.z > 0.3;
    }

    bool should_approach_human() {
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_place_object_operator(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_change_position(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    bool should_turn(){
        // Example condition for approaching a human
        return sensor_data_.hand_position.x < 0.5 && sensor_data_.hand_position.y > 1.0;
    }

    void maintain_current_state() {
        RCLCPP_INFO(this->get_logger(), "Maintaining current state");
    }

    // Subscribers
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_state_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_normal_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr hand_position_sub_;
    rclcpp::Subscription<std_msgs::msg::Float32>::SharedPtr hand_time_sub_;
    rclcpp::Subscription<geometry_msgs::msg::Point>::SharedPtr hand_rate_of_change_sub_;
};

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    std::cout << "hello 1" <<std::endl;
    rclcpp::spin(std::make_shared<ActionManager>());
    std::cout << "hello 1" <<std::endl;
    rclcpp::shutdown();
    return 0;
}



void execute_command(const Command& command) {
    // Create a script with manual spacing and indentation
    std::string script_part1 = "def my_prog():\n";
    std::string script_part2 = "  movej(p[";
    std::string script_part3 = std::to_string(command.position.x) + ", " 
                               + std::to_string(command.position.y) + ", " 
                               + std::to_string(command.position.z) + ", "
                               + std::to_string(command.orientation.x) + ", " 
                               + std::to_string(command.orientation.y) + ", " 
                               + std::to_string(command.orientation.z) + "], a=1.2, v=0.25, r=0)";
    std::string script_part4 = "  textmsg(\"motion finished\")";
    std::string script_part5 = "end";
    
    // Concatenate all parts into one string with manual spacing
    std::string full_script = script_part1 + "  " + script_part2 + "\n"
                             + script_part3 + "\n"
                             + script_part4 + "\n"
                             + script_part5;

    // Create and publish the message
    std_msgs::msg::String msg;
    msg.data = full_script;
    script_command_pub_->publish(msg);
}


data: 'def my_prog():

  movej(p[0.46366, -0.30596, 0.82824, 0.082, 3.153, 0.092], a=1.2, v=0.25, r=0)

  textmsg("motion finished")

  end'
---
data: "def my_prog():\n    movej(p[\n0.246000, -0.240000, 0.031000, 2.077000, -2.303000, 1.151000], a=1.2, v=0.25, r=0)\n  textmsg(\"motion..."
---
data: "def my_prog(): \r\n  movej(p[0.246, -0.24, 0.031, 2.077, -2.303, 1.151], a=1.2, v=0.25, r=0)\r\n  textmsg(\"motion finished\")\r\nend"
---
data: "def my_prog(): \r\n  movej(p[0.246, -0.24, 0.031, 2.077, -2.303, 1.151], a=1.2, v=0.25, r=0)\r\n  textmsg(\"motion finished\")\r\nend"
---
data: "def my_prog(): \r\n  movej(p[0.246, -0.24, 0.031, 2.077, -2.303, 1.151], a=1.2, v=0.25, r=0)\r\n  textmsg(\"motion finished\")\r\nend"
---
data: "def my_prog(): \r\n  movej(p[0.246, -0.24, 0.031, 2.077, -2.303, 1.151], a=1.2, v=0.25, r=0)\r\n  textmsg(\"motion finished\")\r\nend"



cmake_minimum_required(VERSION 3.8)
project(robotiq_driver)

if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES "Clang")
  add_compile_options(-Wall -Wextra -Wpedantic)
endif()


# find dependencies
find_package(ament_cmake REQUIRED)
find_package(hardware_interface REQUIRED)
find_package(pluginlib REQUIRED)
find_package(rclcpp REQUIRED)
find_package(rclcpp_lifecycle REQUIRED)
find_package(serial REQUIRED)
find_package(custom_msgs REQUIRED)


set(THIS_PACKAGE_INCLUDE_DEPENDS
  ament_cmake
  hardware_interface
  pluginlib
  rclcpp
  rclcpp_lifecycle
  serial
  custom_msgs
)

add_library(
  ${PROJECT_NAME}
  SHARED
  src/crc.cpp
  src/hardware_interface.cpp
  src/robotiq_gripper_interface.cpp
)
target_include_directories(
  ${PROJECT_NAME}
  PUBLIC
  $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
  $<INSTALL_INTERFACE:include>
)
ament_target_dependencies(
  ${PROJECT_NAME}
  ${THIS_PACKAGE_INCLUDE_DEPENDS}
)

pluginlib_export_plugin_description_file(hardware_interface hardware_interface_plugin.xml)

add_executable(gripper_interface_test src/gripper_interface_service.cpp)
add_executable(gripper_cmds src/test_interface.cpp)

#add_executable(gripper_interface_test src/gripper_interface_test.cpp)
target_include_directories(gripper_interface_test PRIVATE include)
ament_target_dependencies(gripper_interface_test serial custom_msgs)
target_link_libraries(gripper_interface_test ${PROJECT_NAME})

target_include_directories(gripper_cmds PRIVATE include)
ament_target_dependencies(gripper_cmds serial custom_msgs)
target_link_libraries(gripper_cmds ${PROJECT_NAME})


# INSTALL
install(
  TARGETS ${PROJECT_NAME}
  EXPORT export_${PROJECT_NAME}
  ARCHIVE DESTINATION lib/${PROJECT_NAME}
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)
install(
  TARGETS gripper_interface_test gripper_cmds

  DESTINATION lib/${PROJECT_NAME}
)
install(
  DIRECTORY include/ 
  DESTINATION include
)
install(
  DIRECTORY config
  DESTINATION share/${PROJECT_NAME}
)
install(
  DIRECTORY launch
  DESTINATION share/${PROJECT_NAME}
)

if(BUILD_TESTING)
  find_package(ament_lint_auto REQUIRED)
  # the following line skips the linter which checks for copyrights
  # comment the line when a copyright and license is added to all source files
  set(ament_cmake_copyright_FOUND TRUE)
  # the following line skips cpplint (only works in a git repo)
  # comment the line when this package is in a git repo and when
  # a copyright and license is added to all source files
  set(ament_cmake_cpplint_FOUND TRUE)
  ament_lint_auto_find_test_dependencies()
endif()

## EXPORTS
ament_export_include_directories(
  include
)
ament_export_libraries(
  ${PROJECT_NAME}
)
ament_export_targets(
  export_${PROJECT_NAME}
)
ament_export_dependencies(
  ${THIS_PACKAGE_INCLUDE_DEPENDS}
)

ament_package()

